<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">v3io-kafka-client</a> &gt; <a href="index.source.html" class="el_package">org.apache.kafka.common.utils</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
 * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
 * to You under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package org.apache.kafka.common.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Properties;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.kafka.common.KafkaException;

<span class="nc" id="L50">public class Utils {</span>

    // This matches URIs of formats: host:port and protocol:\\host:port
    // IPv6 is supported with [ip] pattern
<span class="fc" id="L54">    private static final Pattern HOST_PORT_PATTERN = Pattern.compile(&quot;.*?\\[?([0-9a-zA-Z\\-%._:]*)\\]?:([0-9]+)&quot;);</span>

<span class="fc" id="L56">    public static final String NL = System.getProperty(&quot;line.separator&quot;);</span>

<span class="fc" id="L58">    private static final Logger log = LoggerFactory.getLogger(Utils.class);</span>

    /**
     * Get a sorted list representation of a collection.
     * @param collection The collection to sort
     * @param &lt;T&gt; The class of objects in the collection
     * @return An unmodifiable sorted list with the contents of the collection
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; List&lt;T&gt; sorted(Collection&lt;T&gt; collection) {
<span class="nc" id="L67">        List&lt;T&gt; res = new ArrayList&lt;&gt;(collection);</span>
<span class="nc" id="L68">        Collections.sort(res);</span>
<span class="nc" id="L69">        return Collections.unmodifiableList(res);</span>
    }

    /**
     * Turn the given UTF8 byte array into a string
     *
     * @param bytes The byte array
     * @return The string
     */
    public static String utf8(byte[] bytes) {
        try {
<span class="nc" id="L80">            return new String(bytes, &quot;UTF8&quot;);</span>
<span class="nc" id="L81">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L82">            throw new RuntimeException(&quot;This shouldn't happen.&quot;, e);</span>
        }
    }

    /**
     * Turn a string into a utf8 byte[]
     *
     * @param string The string
     * @return The byte[]
     */
    public static byte[] utf8(String string) {
        try {
<span class="nc" id="L94">            return string.getBytes(&quot;UTF8&quot;);</span>
<span class="nc" id="L95">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L96">            throw new RuntimeException(&quot;This shouldn't happen.&quot;, e);</span>
        }
    }

    /**
     * Read an unsigned integer from the current position in the buffer, incrementing the position by 4 bytes
     *
     * @param buffer The buffer to read from
     * @return The integer read, as a long to avoid signedness
     */
    public static long readUnsignedInt(ByteBuffer buffer) {
<span class="nc" id="L107">        return buffer.getInt() &amp; 0xffffffffL;</span>
    }

    /**
     * Read an unsigned integer from the given position without modifying the buffers position
     *
     * @param buffer the buffer to read from
     * @param index the index from which to read the integer
     * @return The integer read, as a long to avoid signedness
     */
    public static long readUnsignedInt(ByteBuffer buffer, int index) {
<span class="nc" id="L118">        return buffer.getInt(index) &amp; 0xffffffffL;</span>
    }

    /**
     * Read an unsigned integer stored in little-endian format from the {@link InputStream}.
     *
     * @param in The stream to read from
     * @return The integer read (MUST BE TREATED WITH SPECIAL CARE TO AVOID SIGNEDNESS)
     */
    public static int readUnsignedIntLE(InputStream in) throws IOException {
<span class="nc" id="L128">        return (in.read() &lt;&lt; 8 * 0)</span>
<span class="nc" id="L129">             | (in.read() &lt;&lt; 8 * 1)</span>
<span class="nc" id="L130">             | (in.read() &lt;&lt; 8 * 2)</span>
<span class="nc" id="L131">             | (in.read() &lt;&lt; 8 * 3);</span>
    }

    /**
     * Get the little-endian value of an integer as a byte array.
     * @param val The value to convert to a little-endian array
     * @return The little-endian encoded array of bytes for the value
     */
    public static byte[] toArrayLE(int val) {
<span class="nc" id="L140">        return new byte[] {</span>
            (byte) (val &gt;&gt; 8 * 0),
            (byte) (val &gt;&gt; 8 * 1),
            (byte) (val &gt;&gt; 8 * 2),
            (byte) (val &gt;&gt; 8 * 3)
        };
    }


    /**
     * Read an unsigned integer stored in little-endian format from a byte array
     * at a given offset.
     *
     * @param buffer The byte array to read from
     * @param offset The position in buffer to read from
     * @return The integer read (MUST BE TREATED WITH SPECIAL CARE TO AVOID SIGNEDNESS)
     */
    public static int readUnsignedIntLE(byte[] buffer, int offset) {
<span class="nc" id="L158">        return (buffer[offset++] &lt;&lt; 8 * 0)</span>
             | (buffer[offset++] &lt;&lt; 8 * 1)
             | (buffer[offset++] &lt;&lt; 8 * 2)
             | (buffer[offset]   &lt;&lt; 8 * 3);
    }

    /**
     * Write the given long value as a 4 byte unsigned integer. Overflow is ignored.
     *
     * @param buffer The buffer to write to
     * @param value The value to write
     */
    public static void writeUnsignedInt(ByteBuffer buffer, long value) {
<span class="nc" id="L171">        buffer.putInt((int) (value &amp; 0xffffffffL));</span>
<span class="nc" id="L172">    }</span>

    /**
     * Write the given long value as a 4 byte unsigned integer. Overflow is ignored.
     *
     * @param buffer The buffer to write to
     * @param index The position in the buffer at which to begin writing
     * @param value The value to write
     */
    public static void writeUnsignedInt(ByteBuffer buffer, int index, long value) {
<span class="nc" id="L182">        buffer.putInt(index, (int) (value &amp; 0xffffffffL));</span>
<span class="nc" id="L183">    }</span>

    /**
     * Write an unsigned integer in little-endian format to the {@link OutputStream}.
     *
     * @param out The stream to write to
     * @param value The value to write
     */
    public static void writeUnsignedIntLE(OutputStream out, int value) throws IOException {
<span class="nc" id="L192">        out.write(value &gt;&gt;&gt; 8 * 0);</span>
<span class="nc" id="L193">        out.write(value &gt;&gt;&gt; 8 * 1);</span>
<span class="nc" id="L194">        out.write(value &gt;&gt;&gt; 8 * 2);</span>
<span class="nc" id="L195">        out.write(value &gt;&gt;&gt; 8 * 3);</span>
<span class="nc" id="L196">    }</span>

    /**
     * Write an unsigned integer in little-endian format to a byte array
     * at a given offset.
     *
     * @param buffer The byte array to write to
     * @param offset The position in buffer to write to
     * @param value The value to write
     */
    public static void writeUnsignedIntLE(byte[] buffer, int offset, int value) {
<span class="nc" id="L207">        buffer[offset++] = (byte) (value &gt;&gt;&gt; 8 * 0);</span>
<span class="nc" id="L208">        buffer[offset++] = (byte) (value &gt;&gt;&gt; 8 * 1);</span>
<span class="nc" id="L209">        buffer[offset++] = (byte) (value &gt;&gt;&gt; 8 * 2);</span>
<span class="nc" id="L210">        buffer[offset]   = (byte) (value &gt;&gt;&gt; 8 * 3);</span>
<span class="nc" id="L211">    }</span>


    /**
     * Get the absolute value of the given number. If the number is Int.MinValue return 0. This is different from
     * java.lang.Math.abs or scala.math.abs in that they return Int.MinValue (!).
     */
    public static int abs(int n) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        return (n == Integer.MIN_VALUE) ? 0 : Math.abs(n);</span>
    }

    /**
     * Get the minimum of some long values.
     * @param first Used to ensure at least one value
     * @param rest The rest of longs to compare
     * @return The minimum of all passed argument.
     */
    public static long min(long first, long ... rest) {
<span class="nc" id="L229">        long min = first;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (int i = 0; i &lt; rest.length; i++) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (rest[i] &lt; min)</span>
<span class="nc" id="L232">                min = rest[i];</span>
        }
<span class="nc" id="L234">        return min;</span>
    }

    /**
     * Get the length for UTF8-encoding a string without encoding it first
     *
     * @param s The string to calculate the length for
     * @return The length when serialized
     */
    public static int utf8Length(CharSequence s) {
<span class="nc" id="L244">        int count = 0;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        for (int i = 0, len = s.length(); i &lt; len; i++) {</span>
<span class="nc" id="L246">            char ch = s.charAt(i);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (ch &lt;= 0x7F) {</span>
<span class="nc" id="L248">                count++;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            } else if (ch &lt;= 0x7FF) {</span>
<span class="nc" id="L250">                count += 2;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            } else if (Character.isHighSurrogate(ch)) {</span>
<span class="nc" id="L252">                count += 4;</span>
<span class="nc" id="L253">                ++i;</span>
            } else {
<span class="nc" id="L255">                count += 3;</span>
            }
        }
<span class="nc" id="L258">        return count;</span>
    }

    /**
     * Read the given byte buffer into a byte array
     */
    public static byte[] toArray(ByteBuffer buffer) {
<span class="nc" id="L265">        return toArray(buffer, 0, buffer.limit());</span>
    }

    /**
     * Read a byte array from the given offset and size in the buffer
     */
    public static byte[] toArray(ByteBuffer buffer, int offset, int size) {
<span class="nc" id="L272">        byte[] dest = new byte[size];</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (buffer.hasArray()) {</span>
<span class="nc" id="L274">            System.arraycopy(buffer.array(), buffer.arrayOffset() + offset, dest, 0, size);</span>
        } else {
<span class="nc" id="L276">            int pos = buffer.position();</span>
<span class="nc" id="L277">            buffer.get(dest);</span>
<span class="nc" id="L278">            buffer.position(pos);</span>
        }
<span class="nc" id="L280">        return dest;</span>
    }

    /**
     * Check that the parameter t is not null
     *
     * @param t The object to check
     * @return t if it isn't null
     * @throws NullPointerException if t is null.
     */
    public static &lt;T&gt; T notNull(T t) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (t == null)</span>
<span class="nc" id="L292">            throw new NullPointerException();</span>
        else
<span class="nc" id="L294">            return t;</span>
    }

    /**
     * Sleep for a bit
     * @param ms The duration of the sleep
     */
    public static void sleep(long ms) {
        try {
<span class="nc" id="L303">            Thread.sleep(ms);</span>
<span class="nc" id="L304">        } catch (InterruptedException e) {</span>
            // this is okay, we just wake up early
<span class="nc" id="L306">        }</span>
<span class="nc" id="L307">    }</span>

    /**
     * Instantiate the class
     */
    public static &lt;T&gt; T newInstance(Class&lt;T&gt; c) {
        try {
<span class="nc" id="L314">            return c.newInstance();</span>
<span class="nc" id="L315">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L316">            throw new KafkaException(&quot;Could not instantiate class &quot; + c.getName(), e);</span>
<span class="nc" id="L317">        } catch (InstantiationException e) {</span>
<span class="nc" id="L318">            throw new KafkaException(&quot;Could not instantiate class &quot; + c.getName() + &quot; Does it have a public no-argument constructor?&quot;, e);</span>
<span class="nc" id="L319">        } catch (NullPointerException e) {</span>
<span class="nc" id="L320">            throw new KafkaException(&quot;Requested class was null&quot;, e);</span>
        }
    }

    /**
     * Look up the class by name and instantiate it.
     * @param klass class name
     * @param base super class of the class to be instantiated
     * @param &lt;T&gt;
     * @return the new instance
     */
    public static &lt;T&gt; T newInstance(String klass, Class&lt;T&gt; base) throws ClassNotFoundException {
<span class="nc" id="L332">        return Utils.newInstance(Class.forName(klass, true, Utils.getContextOrKafkaClassLoader()).asSubclass(base));</span>
    }

    /**
     * Generates 32 bit murmur2 hash from byte array
     * @param data byte array to hash
     * @return 32 bit hash of the given array
     */
    public static int murmur2(final byte[] data) {
<span class="nc" id="L341">        int length = data.length;</span>
<span class="nc" id="L342">        int seed = 0x9747b28c;</span>
        // 'm' and 'r' are mixing constants generated offline.
        // They're not really 'magic', they just happen to work well.
<span class="nc" id="L345">        final int m = 0x5bd1e995;</span>
<span class="nc" id="L346">        final int r = 24;</span>

        // Initialize the hash to a random value
<span class="nc" id="L349">        int h = seed ^ length;</span>
<span class="nc" id="L350">        int length4 = length / 4;</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">        for (int i = 0; i &lt; length4; i++) {</span>
<span class="nc" id="L353">            final int i4 = i * 4;</span>
<span class="nc" id="L354">            int k = (data[i4 + 0] &amp; 0xff) + ((data[i4 + 1] &amp; 0xff) &lt;&lt; 8) + ((data[i4 + 2] &amp; 0xff) &lt;&lt; 16) + ((data[i4 + 3] &amp; 0xff) &lt;&lt; 24);</span>
<span class="nc" id="L355">            k *= m;</span>
<span class="nc" id="L356">            k ^= k &gt;&gt;&gt; r;</span>
<span class="nc" id="L357">            k *= m;</span>
<span class="nc" id="L358">            h *= m;</span>
<span class="nc" id="L359">            h ^= k;</span>
        }

        // Handle the last few bytes of the input array
<span class="nc bnc" id="L363" title="All 4 branches missed.">        switch (length % 4) {</span>
            case 3:
<span class="nc" id="L365">                h ^= (data[(length &amp; ~3) + 2] &amp; 0xff) &lt;&lt; 16;</span>
            case 2:
<span class="nc" id="L367">                h ^= (data[(length &amp; ~3) + 1] &amp; 0xff) &lt;&lt; 8;</span>
            case 1:
<span class="nc" id="L369">                h ^= data[length &amp; ~3] &amp; 0xff;</span>
<span class="nc" id="L370">                h *= m;</span>
        }

<span class="nc" id="L373">        h ^= h &gt;&gt;&gt; 13;</span>
<span class="nc" id="L374">        h *= m;</span>
<span class="nc" id="L375">        h ^= h &gt;&gt;&gt; 15;</span>

<span class="nc" id="L377">        return h;</span>
    }

    /**
     * Extracts the hostname from a &quot;host:port&quot; address string.
     * @param address address string to parse
     * @return hostname or null if the given address is incorrect
     */
    public static String getHost(String address) {
<span class="nc" id="L386">        Matcher matcher = HOST_PORT_PATTERN.matcher(address);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        return matcher.matches() ? matcher.group(1) : null;</span>
    }

    /**
     * Extracts the port number from a &quot;host:port&quot; address string.
     * @param address address string to parse
     * @return port number or null if the given address is incorrect
     */
    public static Integer getPort(String address) {
<span class="nc" id="L396">        Matcher matcher = HOST_PORT_PATTERN.matcher(address);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        return matcher.matches() ? Integer.parseInt(matcher.group(2)) : null;</span>
    }

    /**
     * Formats hostname and port number as a &quot;host:port&quot; address string,
     * surrounding IPv6 addresses with braces '[', ']'
     * @param host hostname
     * @param port port number
     * @return address string
     */
    public static String formatAddress(String host, Integer port) {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        return host.contains(&quot;:&quot;)</span>
                ? &quot;[&quot; + host + &quot;]:&quot; + port // IPv6
                : host + &quot;:&quot; + port;
    }

    /**
     * Create a string representation of an array joined by the given separator
     * @param strs The array of items
     * @param seperator The separator
     * @return The string representation.
     */
    public static &lt;T&gt; String join(T[] strs, String seperator) {
<span class="nc" id="L420">        return join(Arrays.asList(strs), seperator);</span>
    }

    /**
     * Create a string representation of a list joined by the given separator
     * @param list The list of items
     * @param seperator The separator
     * @return The string representation.
     */
    public static &lt;T&gt; String join(Collection&lt;T&gt; list, String seperator) {
<span class="nc" id="L430">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L431">        Iterator&lt;T&gt; iter = list.iterator();</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L433">            sb.append(iter.next());</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (iter.hasNext())</span>
<span class="nc" id="L435">                sb.append(seperator);</span>
        }
<span class="nc" id="L437">        return sb.toString();</span>
    }

    /**
     * Read a properties file from the given path
     * @param filename The path of the file to read
     */
    public static Properties loadProps(String filename) throws IOException, FileNotFoundException {
<span class="nc" id="L445">        Properties props = new Properties();</span>
<span class="nc" id="L446">        try (InputStream propStream = new FileInputStream(filename)) {</span>
<span class="nc" id="L447">            props.load(propStream);</span>
<span class="nc bnc" id="L448" title="All 8 branches missed.">        }</span>
<span class="nc" id="L449">        return props;</span>
    }

    /**
     * Converts a Properties object to a Map&lt;String, String&gt;, calling {@link #toString} to ensure all keys and values
     * are Strings.
     */
    public static Map&lt;String, String&gt; propsToStringMap(Properties props) {
<span class="nc" id="L457">        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        for (Map.Entry&lt;Object, Object&gt; entry : props.entrySet())</span>
<span class="nc" id="L459">            result.put(entry.getKey().toString(), entry.getValue().toString());</span>
<span class="nc" id="L460">        return result;</span>
    }

    /**
     * Get the stack trace from an exception as a string
     */
    public static String stackTrace(Throwable e) {
<span class="nc" id="L467">        StringWriter sw = new StringWriter();</span>
<span class="nc" id="L468">        PrintWriter pw = new PrintWriter(sw);</span>
<span class="nc" id="L469">        e.printStackTrace(pw);</span>
<span class="nc" id="L470">        return sw.toString();</span>
    }

    /**
     * Create a new thread
     * @param name The name of the thread
     * @param runnable The work for the thread to do
     * @param daemon Should the thread block JVM shutdown?
     * @return The unstarted thread
     */
    public static Thread newThread(String name, Runnable runnable, boolean daemon) {
<span class="nc" id="L481">        Thread thread = new Thread(runnable, name);</span>
<span class="nc" id="L482">        thread.setDaemon(daemon);</span>
<span class="nc" id="L483">        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {</span>
            public void uncaughtException(Thread t, Throwable e) {
<span class="nc" id="L485">                log.error(&quot;Uncaught exception in thread '&quot; + t.getName() + &quot;':&quot;, e);</span>
<span class="nc" id="L486">            }</span>
        });
<span class="nc" id="L488">        return thread;</span>
    }

    /**
     * Create a daemon thread
     * @param name The name of the thread
     * @param runnable The runnable to execute in the background
     * @return The unstarted thread
     */
    public static Thread daemonThread(String name, Runnable runnable) {
<span class="nc" id="L498">        return newThread(name, runnable, true);</span>
    }

    /**
     * Print an error message and shutdown the JVM
     * @param message The error message
     */
    public static void croak(String message) {
<span class="nc" id="L506">        System.err.println(message);</span>
<span class="nc" id="L507">        System.exit(1);</span>
<span class="nc" id="L508">    }</span>

    /**
     * Read a buffer into a Byte array for the given offset and length
     */
    public static byte[] readBytes(ByteBuffer buffer, int offset, int length) {
<span class="nc" id="L514">        byte[] dest = new byte[length];</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (buffer.hasArray()) {</span>
<span class="nc" id="L516">            System.arraycopy(buffer.array(), buffer.arrayOffset() + offset, dest, 0, length);</span>
        } else {
<span class="nc" id="L518">            buffer.mark();</span>
<span class="nc" id="L519">            buffer.position(offset);</span>
<span class="nc" id="L520">            buffer.get(dest, 0, length);</span>
<span class="nc" id="L521">            buffer.reset();</span>
        }
<span class="nc" id="L523">        return dest;</span>
    }

    /**
     * Read the given byte buffer into a Byte array
     */
    public static byte[] readBytes(ByteBuffer buffer) {
<span class="nc" id="L530">        return Utils.readBytes(buffer, 0, buffer.limit());</span>
    }

    /**
     * Attempt to read a file as a string
     * @throws IOException
     */
    public static String readFileAsString(String path, Charset charset) throws IOException {
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (charset == null) charset = Charset.defaultCharset();</span>

<span class="nc" id="L540">        try (FileInputStream stream = new FileInputStream(new File(path))) {</span>
<span class="nc" id="L541">            FileChannel fc = stream.getChannel();</span>
<span class="nc" id="L542">            MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());</span>
<span class="nc" id="L543">            return charset.decode(bb).toString();</span>
<span class="nc bnc" id="L544" title="All 8 branches missed.">        }</span>

    }

    public static String readFileAsString(String path) throws IOException {
<span class="nc" id="L549">        return Utils.readFileAsString(path, Charset.defaultCharset());</span>
    }

    /**
     * Check if the given ByteBuffer capacity
     * @param existingBuffer ByteBuffer capacity to check
     * @param newLength new length for the ByteBuffer.
     * returns ByteBuffer
     */
    public static ByteBuffer ensureCapacity(ByteBuffer existingBuffer, int newLength) {
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (newLength &gt; existingBuffer.capacity()) {</span>
<span class="nc" id="L560">            ByteBuffer newBuffer = ByteBuffer.allocate(newLength);</span>
<span class="nc" id="L561">            existingBuffer.flip();</span>
<span class="nc" id="L562">            newBuffer.put(existingBuffer);</span>
<span class="nc" id="L563">            return newBuffer;</span>
        }
<span class="nc" id="L565">        return existingBuffer;</span>
    }

    /*
     * Creates a set
     * @param elems the elements
     * @param &lt;T&gt; the type of element
     * @return Set
     */
    @SafeVarargs
    public static &lt;T&gt; Set&lt;T&gt; mkSet(T... elems) {
<span class="nc" id="L576">        return new HashSet&lt;&gt;(Arrays.asList(elems));</span>
    }

    /*
     * Creates a list
     * @param elems the elements
     * @param &lt;T&gt; the type of element
     * @return List
     */
    @SafeVarargs
    public static &lt;T&gt; List&lt;T&gt; mkList(T... elems) {
<span class="nc" id="L587">        return Arrays.asList(elems);</span>
    }


    /*
     * Create a string from a collection
     * @param coll the collection
     * @param separator the separator
     */
    public static &lt;T&gt; CharSequence mkString(Collection&lt;T&gt; coll, String separator) {
<span class="fc" id="L597">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L598">        Iterator&lt;T&gt; iter = coll.iterator();</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">        if (iter.hasNext()) {</span>
<span class="fc" id="L600">            sb.append(iter.next().toString());</span>

<span class="fc bfc" id="L602" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L603">                sb.append(separator);</span>
<span class="fc" id="L604">                sb.append(iter.next().toString());</span>
            }
        }
<span class="fc" id="L607">        return sb;</span>
    }

    /**
     * Recursively delete the given file/directory and any subfiles (if any exist)
     *
     * @param file The root file at which to begin deleting
     */
    public static void delete(File file) {
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (file == null) {</span>
<span class="nc" id="L617">            return;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">        } else if (file.isDirectory()) {</span>
<span class="nc" id="L619">            File[] files = file.listFiles();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            if (files != null) {</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                for (File f : files)</span>
<span class="nc" id="L622">                    delete(f);</span>
            }
<span class="nc" id="L624">            file.delete();</span>
<span class="nc" id="L625">        } else {</span>
<span class="nc" id="L626">            file.delete();</span>
        }
<span class="nc" id="L628">    }</span>

    /**
     * Returns an empty collection if this list is null
     * @param other
     * @return
     */
    public static &lt;T&gt; List&lt;T&gt; safe(List&lt;T&gt; other) {
<span class="nc bnc" id="L636" title="All 2 branches missed.">        return other == null ? Collections.&lt;T&gt;emptyList() : other;</span>
    }

   /**
    * Get the ClassLoader which loaded Kafka.
    */
    public static ClassLoader getKafkaClassLoader() {
<span class="nc" id="L643">        return Utils.class.getClassLoader();</span>
    }

    /**
     * Get the Context ClassLoader on this thread or, if not present, the ClassLoader that
     * loaded Kafka.
     *
     * This should be used whenever passing a ClassLoader to Class.forName
     */
    public static ClassLoader getContextOrKafkaClassLoader() {
<span class="nc" id="L653">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if (cl == null)</span>
<span class="nc" id="L655">            return getKafkaClassLoader();</span>
        else
<span class="nc" id="L657">            return cl;</span>
    }

    /**
     * Attempts to move source to target atomically and falls back to a non-atomic move if it fails.
     *
     * @throws IOException if both atomic and non-atomic moves fail
     */
    public static void atomicMoveWithFallback(Path source, Path target) throws IOException {
        try {
<span class="nc" id="L667">            Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span>
<span class="nc" id="L668">        } catch (IOException outer) {</span>
            try {
<span class="nc" id="L670">                Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);</span>
<span class="nc" id="L671">                log.debug(&quot;Non-atomic move of &quot; + source + &quot; to &quot; + target + &quot; succeeded after atomic move failed due to &quot;</span>
<span class="nc" id="L672">                        + outer.getMessage());</span>
<span class="nc" id="L673">            } catch (IOException inner) {</span>
<span class="nc" id="L674">                inner.addSuppressed(outer);</span>
<span class="nc" id="L675">                throw inner;</span>
<span class="nc" id="L676">            }</span>
<span class="nc" id="L677">        }</span>
<span class="nc" id="L678">    }</span>

    /**
     * Closes all the provided closeables.
     * @throws IOException if any of the close methods throws an IOException.
     *         The first IOException is thrown with subsequent exceptions
     *         added as suppressed exceptions.
     */
    public static void closeAll(Closeable... closeables) throws IOException {
<span class="nc" id="L687">        IOException exception = null;</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        for (Closeable closeable : closeables) {</span>
            try {
<span class="nc" id="L690">                closeable.close();</span>
<span class="nc" id="L691">            } catch (IOException e) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                if (exception != null)</span>
<span class="nc" id="L693">                    exception.addSuppressed(e);</span>
                else
<span class="nc" id="L695">                    exception = e;</span>
<span class="nc" id="L696">            }</span>
        }
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (exception != null)</span>
<span class="nc" id="L699">            throw exception;</span>
<span class="nc" id="L700">    }</span>

    /**
     * Closes {@code closeable} and if an exception is thrown, it is logged at the WARN level.
     */
    public static void closeQuietly(Closeable closeable, String name) {
<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (closeable != null) {</span>
            try {
<span class="nc" id="L708">                closeable.close();</span>
<span class="nc" id="L709">            } catch (Throwable t) {</span>
<span class="nc" id="L710">                log.warn(&quot;Failed to close &quot; + name, t);</span>
<span class="nc" id="L711">            }</span>
        }
<span class="nc" id="L713">    }</span>

    /**
     * A cheap way to deterministically convert a number to a positive value. When the input is
     * positive, the original value is returned. When the input number is negative, the returned
     * positive value is the original value bit AND against 0x7fffffff which is not its absolutely
     * value.
     *
     * Note: changing this method in the future will possibly cause partition selection not to be
     * compatible with the existing messages already placed on a partition since it is used
     * in producer's {@link org.apache.kafka.clients.producer.internals.DefaultPartitioner}
     *
     * @param number a given number
     * @return a positive number.
     */
    public static int toPositive(int number) {
<span class="nc" id="L729">        return number &amp; 0x7fffffff;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>