<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Record.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">v3io-kafka-client</a> &gt; <a href="index.source.html" class="el_package">org.apache.kafka.common.record</a> &gt; <span class="el_source">Record.java</span></div><h1>Record.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.kafka.common.record;

import java.nio.ByteBuffer;

import org.apache.kafka.common.utils.Crc32;
import org.apache.kafka.common.utils.Utils;


/**
 * A record: a serialized key and value along with the associated CRC and other fields
 */
public final class Record {

    /**
     * The current offset and size for all the fixed-length fields
     */
    public static final int CRC_OFFSET = 0;
    public static final int CRC_LENGTH = 4;
    public static final int MAGIC_OFFSET = CRC_OFFSET + CRC_LENGTH;
    public static final int MAGIC_LENGTH = 1;
    public static final int ATTRIBUTES_OFFSET = MAGIC_OFFSET + MAGIC_LENGTH;
    public static final int ATTRIBUTE_LENGTH = 1;
    public static final int TIMESTAMP_OFFSET = ATTRIBUTES_OFFSET + ATTRIBUTE_LENGTH;
    public static final int TIMESTAMP_LENGTH = 8;
    public static final int KEY_SIZE_OFFSET_V0 = ATTRIBUTES_OFFSET + ATTRIBUTE_LENGTH;
    public static final int KEY_SIZE_OFFSET_V1 = TIMESTAMP_OFFSET + TIMESTAMP_LENGTH;
    public static final int KEY_SIZE_LENGTH = 4;
    public static final int KEY_OFFSET_V0 = KEY_SIZE_OFFSET_V0 + KEY_SIZE_LENGTH;
    public static final int KEY_OFFSET_V1 = KEY_SIZE_OFFSET_V1 + KEY_SIZE_LENGTH;
    public static final int VALUE_SIZE_LENGTH = 4;

    /**
     * The size for the record header
     */
    public static final int HEADER_SIZE = CRC_LENGTH + MAGIC_LENGTH + ATTRIBUTE_LENGTH;

    /**
     * The amount of overhead bytes in a record
     */
    public static final int RECORD_OVERHEAD = HEADER_SIZE + TIMESTAMP_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH;

    /**
     * The &quot;magic&quot; values
     */
    public static final byte MAGIC_VALUE_V0 = 0;
    public static final byte MAGIC_VALUE_V1 = 1;

    /**
     * The current &quot;magic&quot; value
     */
    public static final byte CURRENT_MAGIC_VALUE = MAGIC_VALUE_V1;

    /**
     * Specifies the mask for the compression code. 3 bits to hold the compression codec. 0 is reserved to indicate no
     * compression
     */
    public static final int COMPRESSION_CODEC_MASK = 0x07;

    /**
     * Specify the mask of timestamp type.
     * 0 for CreateTime, 1 for LogAppendTime.
     */
    public static final byte TIMESTAMP_TYPE_MASK = 0x08;
    public static final int TIMESTAMP_TYPE_ATTRIBUTE_OFFSET = 3;

    /**
     * Compression code for uncompressed records
     */
    public static final int NO_COMPRESSION = 0;

    /**
     * Timestamp value for records without a timestamp
     */
    public static final long NO_TIMESTAMP = -1L;

    private final ByteBuffer buffer;
    private final Long wrapperRecordTimestamp;
    private final TimestampType wrapperRecordTimestampType;

<span class="nc" id="L96">    public Record(ByteBuffer buffer) {</span>
<span class="nc" id="L97">        this.buffer = buffer;</span>
<span class="nc" id="L98">        this.wrapperRecordTimestamp = null;</span>
<span class="nc" id="L99">        this.wrapperRecordTimestampType = null;</span>
<span class="nc" id="L100">    }</span>

    // Package private constructor for inner iteration.
<span class="nc" id="L103">    Record(ByteBuffer buffer, Long wrapperRecordTimestamp, TimestampType wrapperRecordTimestampType) {</span>
<span class="nc" id="L104">        this.buffer = buffer;</span>
<span class="nc" id="L105">        this.wrapperRecordTimestamp = wrapperRecordTimestamp;</span>
<span class="nc" id="L106">        this.wrapperRecordTimestampType = wrapperRecordTimestampType;</span>
<span class="nc" id="L107">    }</span>

    /**
     * A constructor to create a LogRecord. If the record's compression type is not none, then
     * its value payload should be already compressed with the specified type; the constructor
     * would always write the value payload as is and will not do the compression itself.
     *
     * @param timestamp The timestamp of the record
     * @param key The key of the record (null, if none)
     * @param value The record value
     * @param type The compression type used on the contents of the record (if any)
     * @param valueOffset The offset into the payload array used to extract payload
     * @param valueSize The size of the payload to use
     */
    public Record(long timestamp, byte[] key, byte[] value, CompressionType type, int valueOffset, int valueSize) {
<span class="nc bnc" id="L122" title="All 6 branches missed.">        this(ByteBuffer.allocate(recordSize(key == null ? 0 : key.length,</span>
            value == null ? 0 : valueSize &gt;= 0 ? valueSize : value.length - valueOffset)));
<span class="nc" id="L124">        write(this.buffer, timestamp, key, value, type, valueOffset, valueSize);</span>
<span class="nc" id="L125">        this.buffer.rewind();</span>
<span class="nc" id="L126">    }</span>

    public Record(long timestamp, byte[] key, byte[] value, CompressionType type) {
<span class="nc" id="L129">        this(timestamp, key, value, type, 0, -1);</span>
<span class="nc" id="L130">    }</span>

    public Record(long timestamp, byte[] value, CompressionType type) {
<span class="nc" id="L133">        this(timestamp, null, value, type);</span>
<span class="nc" id="L134">    }</span>

    public Record(long timestamp, byte[] key, byte[] value) {
<span class="nc" id="L137">        this(timestamp, key, value, CompressionType.NONE);</span>
<span class="nc" id="L138">    }</span>

    public Record(long timestamp, byte[] value) {
<span class="nc" id="L141">        this(timestamp, null, value, CompressionType.NONE);</span>
<span class="nc" id="L142">    }</span>

    // Write a record to the buffer, if the record's compression type is none, then
    // its value payload should be already compressed with the specified type
    public static void write(ByteBuffer buffer, long timestamp, byte[] key, byte[] value, CompressionType type, int valueOffset, int valueSize) {
        // construct the compressor with compression type none since this function will not do any
        //compression according to the input type, it will just write the record's payload as is
<span class="nc" id="L149">        Compressor compressor = new Compressor(buffer, CompressionType.NONE);</span>
        try {
<span class="nc" id="L151">            compressor.putRecord(timestamp, key, value, type, valueOffset, valueSize);</span>
        } finally {
<span class="nc" id="L153">            compressor.close();</span>
<span class="nc" id="L154">        }</span>
<span class="nc" id="L155">    }</span>

    public static void write(Compressor compressor, long crc, byte attributes, long timestamp, byte[] key, byte[] value, int valueOffset, int valueSize) {
        // write crc
<span class="nc" id="L159">        compressor.putInt((int) (crc &amp; 0xffffffffL));</span>
        // write magic value
<span class="nc" id="L161">        compressor.putByte(CURRENT_MAGIC_VALUE);</span>
        // write attributes
<span class="nc" id="L163">        compressor.putByte(attributes);</span>
        // write timestamp
<span class="nc" id="L165">        compressor.putLong(timestamp);</span>
        // write the key
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L168">            compressor.putInt(-1);</span>
        } else {
<span class="nc" id="L170">            compressor.putInt(key.length);</span>
<span class="nc" id="L171">            compressor.put(key, 0, key.length);</span>
        }
        // write the value
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L175">            compressor.putInt(-1);</span>
        } else {
<span class="nc bnc" id="L177" title="All 2 branches missed.">            int size = valueSize &gt;= 0 ? valueSize : (value.length - valueOffset);</span>
<span class="nc" id="L178">            compressor.putInt(size);</span>
<span class="nc" id="L179">            compressor.put(value, valueOffset, size);</span>
        }
<span class="nc" id="L181">    }</span>

    public static int recordSize(byte[] key, byte[] value) {
<span class="nc bnc" id="L184" title="All 4 branches missed.">        return recordSize(key == null ? 0 : key.length, value == null ? 0 : value.length);</span>
    }

    public static int recordSize(int keySize, int valueSize) {
<span class="nc" id="L188">        return CRC_LENGTH + MAGIC_LENGTH + ATTRIBUTE_LENGTH + TIMESTAMP_LENGTH + KEY_SIZE_LENGTH + keySize + VALUE_SIZE_LENGTH + valueSize;</span>
    }

    public ByteBuffer buffer() {
<span class="nc" id="L192">        return this.buffer;</span>
    }

    public static byte computeAttributes(CompressionType type) {
<span class="nc" id="L196">        byte attributes = 0;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (type.id &gt; 0)</span>
<span class="nc" id="L198">            attributes = (byte) (attributes | (COMPRESSION_CODEC_MASK &amp; type.id));</span>
<span class="nc" id="L199">        return attributes;</span>
    }

    /**
     * Compute the checksum of the record from the record contents
     */
    public static long computeChecksum(ByteBuffer buffer, int position, int size) {
<span class="nc" id="L206">        Crc32 crc = new Crc32();</span>
<span class="nc" id="L207">        crc.update(buffer.array(), buffer.arrayOffset() + position, size);</span>
<span class="nc" id="L208">        return crc.getValue();</span>
    }

    /**
     * Compute the checksum of the record from the attributes, key and value payloads
     */
    public static long computeChecksum(long timestamp, byte[] key, byte[] value, CompressionType type, int valueOffset, int valueSize) {
<span class="nc" id="L215">        Crc32 crc = new Crc32();</span>
<span class="nc" id="L216">        crc.update(CURRENT_MAGIC_VALUE);</span>
<span class="nc" id="L217">        byte attributes = 0;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (type.id &gt; 0)</span>
<span class="nc" id="L219">            attributes = (byte) (attributes | (COMPRESSION_CODEC_MASK &amp; type.id));</span>
<span class="nc" id="L220">        crc.update(attributes);</span>
<span class="nc" id="L221">        crc.updateLong(timestamp);</span>
        // update for the key
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L224">            crc.updateInt(-1);</span>
        } else {
<span class="nc" id="L226">            crc.updateInt(key.length);</span>
<span class="nc" id="L227">            crc.update(key, 0, key.length);</span>
        }
        // update for the value
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L231">            crc.updateInt(-1);</span>
        } else {
<span class="nc bnc" id="L233" title="All 2 branches missed.">            int size = valueSize &gt;= 0 ? valueSize : (value.length - valueOffset);</span>
<span class="nc" id="L234">            crc.updateInt(size);</span>
<span class="nc" id="L235">            crc.update(value, valueOffset, size);</span>
        }
<span class="nc" id="L237">        return crc.getValue();</span>
    }


    /**
     * Compute the checksum of the record from the record contents
     */
    public long computeChecksum() {
<span class="nc" id="L245">        return computeChecksum(buffer, MAGIC_OFFSET, buffer.limit() - MAGIC_OFFSET);</span>
    }

    /**
     * Retrieve the previously computed CRC for this record
     */
    public long checksum() {
<span class="nc" id="L252">        return Utils.readUnsignedInt(buffer, CRC_OFFSET);</span>
    }

    /**
     * Returns true if the crc stored with the record matches the crc computed off the record contents
     */
    public boolean isValid() {
<span class="nc bnc" id="L259" title="All 4 branches missed.">        return size() &gt;= CRC_LENGTH &amp;&amp; checksum() == computeChecksum();</span>
    }

    /**
     * Throw an InvalidRecordException if isValid is false for this record
     */
    public void ensureValid() {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (!isValid()) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (size() &lt; CRC_LENGTH)</span>
<span class="nc" id="L268">                throw new InvalidRecordException(&quot;Record is corrupt (crc could not be retrieved as the record is too &quot;</span>
<span class="nc" id="L269">                        + &quot;small, size = &quot; + size() + &quot;)&quot;);</span>
            else
<span class="nc" id="L271">                throw new InvalidRecordException(&quot;Record is corrupt (stored crc = &quot; + checksum()</span>
<span class="nc" id="L272">                        + &quot;, computed crc = &quot; + computeChecksum() + &quot;)&quot;);</span>
        }
<span class="nc" id="L274">    }</span>

    /**
     * The complete serialized size of this record in bytes (including crc, header attributes, etc)
     */
    public int size() {
<span class="nc" id="L280">        return buffer.limit();</span>
    }

    /**
     * The length of the key in bytes
     */
    public int keySize() {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (magic() == MAGIC_VALUE_V0)</span>
<span class="nc" id="L288">            return buffer.getInt(KEY_SIZE_OFFSET_V0);</span>
        else
<span class="nc" id="L290">            return buffer.getInt(KEY_SIZE_OFFSET_V1);</span>
    }

    /**
     * Does the record have a key?
     */
    public boolean hasKey() {
<span class="nc bnc" id="L297" title="All 2 branches missed.">        return keySize() &gt;= 0;</span>
    }

    /**
     * The position where the value size is stored
     */
    private int valueSizeOffset() {
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (magic() == MAGIC_VALUE_V0)</span>
<span class="nc" id="L305">            return KEY_OFFSET_V0 + Math.max(0, keySize());</span>
        else
<span class="nc" id="L307">            return KEY_OFFSET_V1 + Math.max(0, keySize());</span>
    }

    /**
     * The length of the value in bytes
     */
    public int valueSize() {
<span class="nc" id="L314">        return buffer.getInt(valueSizeOffset());</span>
    }

    /**
     * The magic version of this record
     */
    public byte magic() {
<span class="nc" id="L321">        return buffer.get(MAGIC_OFFSET);</span>
    }

    /**
     * The attributes stored with this record
     */
    public byte attributes() {
<span class="nc" id="L328">        return buffer.get(ATTRIBUTES_OFFSET);</span>
    }

    /**
     * When magic value is greater than 0, the timestamp of a record is determined in the following way:
     * 1. wrapperRecordTimestampType = null and wrapperRecordTimestamp is null - Uncompressed message, timestamp is in the message.
     * 2. wrapperRecordTimestampType = LOG_APPEND_TIME and WrapperRecordTimestamp is not null - Compressed message using LOG_APPEND_TIME
     * 3. wrapperRecordTimestampType = CREATE_TIME and wrapperRecordTimestamp is not null - Compressed message using CREATE_TIME
     */
    public long timestamp() {
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (magic() == MAGIC_VALUE_V0)</span>
<span class="nc" id="L339">            return NO_TIMESTAMP;</span>
        else {
            // case 2
<span class="nc bnc" id="L342" title="All 4 branches missed.">            if (wrapperRecordTimestampType == TimestampType.LOG_APPEND_TIME &amp;&amp; wrapperRecordTimestamp != null)</span>
<span class="nc" id="L343">                return wrapperRecordTimestamp;</span>
            // Case 1, 3
            else
<span class="nc" id="L346">                return buffer.getLong(TIMESTAMP_OFFSET);</span>
        }
    }

    /**
     * The timestamp of the message.
     */
    public TimestampType timestampType() {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (magic() == 0)</span>
<span class="nc" id="L355">            return TimestampType.NO_TIMESTAMP_TYPE;</span>
        else
<span class="nc bnc" id="L357" title="All 2 branches missed.">            return wrapperRecordTimestampType == null ? TimestampType.forAttributes(attributes()) : wrapperRecordTimestampType;</span>
    }

    /**
     * The compression type used with this record
     */
    public CompressionType compressionType() {
<span class="nc" id="L364">        return CompressionType.forId(buffer.get(ATTRIBUTES_OFFSET) &amp; COMPRESSION_CODEC_MASK);</span>
    }

    /**
     * A ByteBuffer containing the value of this record
     */
    public ByteBuffer value() {
<span class="nc" id="L371">        return sliceDelimited(valueSizeOffset());</span>
    }

    /**
     * A ByteBuffer containing the message key
     */
    public ByteBuffer key() {
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (magic() == MAGIC_VALUE_V0)</span>
<span class="nc" id="L379">            return sliceDelimited(KEY_SIZE_OFFSET_V0);</span>
        else
<span class="nc" id="L381">            return sliceDelimited(KEY_SIZE_OFFSET_V1);</span>
    }

    /**
     * Read a size-delimited byte buffer starting at the given offset
     */
    private ByteBuffer sliceDelimited(int start) {
<span class="nc" id="L388">        int size = buffer.getInt(start);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (size &lt; 0) {</span>
<span class="nc" id="L390">            return null;</span>
        } else {
<span class="nc" id="L392">            ByteBuffer b = buffer.duplicate();</span>
<span class="nc" id="L393">            b.position(start + 4);</span>
<span class="nc" id="L394">            b = b.slice();</span>
<span class="nc" id="L395">            b.limit(size);</span>
<span class="nc" id="L396">            b.rewind();</span>
<span class="nc" id="L397">            return b;</span>
        }
    }

    public String toString() {
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (magic() &gt; 0)</span>
<span class="nc" id="L403">            return String.format(&quot;Record(magic = %d, attributes = %d, compression = %s, crc = %d, %s = %d, key = %d bytes, value = %d bytes)&quot;,</span>
<span class="nc" id="L404">                                 magic(),</span>
<span class="nc" id="L405">                                 attributes(),</span>
<span class="nc" id="L406">                                 compressionType(),</span>
<span class="nc" id="L407">                                 checksum(),</span>
<span class="nc" id="L408">                                 timestampType(),</span>
<span class="nc" id="L409">                                 timestamp(),</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                                 key() == null ? 0 : key().limit(),</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                                 value() == null ? 0 : value().limit());</span>
        else
<span class="nc" id="L413">            return String.format(&quot;Record(magic = %d, attributes = %d, compression = %s, crc = %d, key = %d bytes, value = %d bytes)&quot;,</span>
<span class="nc" id="L414">                                 magic(),</span>
<span class="nc" id="L415">                                 attributes(),</span>
<span class="nc" id="L416">                                 compressionType(),</span>
<span class="nc" id="L417">                                 checksum(),</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                                 key() == null ? 0 : key().limit(),</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                                 value() == null ? 0 : value().limit());</span>
    }

    public boolean equals(Object other) {
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (this == other)</span>
<span class="nc" id="L424">            return true;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (other == null)</span>
<span class="nc" id="L426">            return false;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (!other.getClass().equals(Record.class))</span>
<span class="nc" id="L428">            return false;</span>
<span class="nc" id="L429">        Record record = (Record) other;</span>
<span class="nc" id="L430">        return this.buffer.equals(record.buffer);</span>
    }

    public int hashCode() {
<span class="nc" id="L434">        return buffer.hashCode();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>