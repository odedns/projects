<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Bytes.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">v3io-kafka-client</a> &gt; <a href="index.source.html" class="el_package">org.apache.kafka.common.utils</a> &gt; <span class="el_source">Bytes.java</span></div><h1>Bytes.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.kafka.common.utils;

import java.util.Arrays;
import java.util.Comparator;

/**
 * Utility class that handles immutable byte arrays.
 */
public class Bytes implements Comparable&lt;Bytes&gt; {

<span class="nc" id="L28">    private static final char[] HEX_CHARS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};</span>

    private final byte[] bytes;

    // cache the hash code for the string, default to 0
    private int hashCode;

    public static Bytes wrap(byte[] bytes) {
<span class="nc" id="L36">        return new Bytes(bytes);</span>
    }

    /**
     * Create a Bytes using the byte array.
     *
     * @param bytes This array becomes the backing storage for the object.
     */
<span class="nc" id="L44">    public Bytes(byte[] bytes) {</span>
<span class="nc" id="L45">        this.bytes = bytes;</span>

        // initialize hash code to 0
<span class="nc" id="L48">        hashCode = 0;</span>
<span class="nc" id="L49">    }</span>

    /**
     * Get the data from the Bytes.
     * @return The data is only valid between offset and offset+length.
     */
    public byte[] get() {
<span class="nc" id="L56">        return this.bytes;</span>
    }

    /**
     * The hashcode is cached except for the case where it is computed as 0, in which
     * case we compute the hashcode on every call.
     *
     * @return the hashcode
     */
    @Override
    public int hashCode() {
<span class="nc bnc" id="L67" title="All 2 branches missed.">        if (hashCode == 0) {</span>
<span class="nc" id="L68">            hashCode = Arrays.hashCode(bytes);</span>
        }

<span class="nc" id="L71">        return hashCode;</span>
    }

    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (this == other)</span>
<span class="nc" id="L77">            return true;</span>

        // we intentionally use the function to compute hashcode here
<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (this.hashCode() != other.hashCode())</span>
<span class="nc" id="L81">            return false;</span>

<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (other instanceof Bytes)</span>
<span class="nc" id="L84">            return Arrays.equals(this.bytes, ((Bytes) other).get());</span>

<span class="nc" id="L86">        return false;</span>
    }

    @Override
    public int compareTo(Bytes that) {
<span class="nc" id="L91">        return BYTES_LEXICO_COMPARATOR.compare(this.bytes, that.bytes);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L96">        return Bytes.toString(bytes, 0, bytes.length);</span>
    }

    /**
     * Write a printable representation of a byte array. Non-printable
     * characters are hex escaped in the format \\x%02X, eg:
     * \x00 \x05 etc.
     *
     * This function is brought from org.apache.hadoop.hbase.util.Bytes
     *
     * @param b array to write out
     * @param off offset to start at
     * @param len length to write
     * @return string output
     */
    private static String toString(final byte[] b, int off, int len) {
<span class="nc" id="L112">        StringBuilder result = new StringBuilder();</span>

<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (b == null)</span>
<span class="nc" id="L115">            return result.toString();</span>

        // just in case we are passed a 'len' that is &gt; buffer length...
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (off &gt;= b.length)</span>
<span class="nc" id="L119">            return result.toString();</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (off + len &gt; b.length)</span>
<span class="nc" id="L122">            len = b.length - off;</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">        for (int i = off; i &lt; off + len; ++i) {</span>
<span class="nc" id="L125">            int ch = b[i] &amp; 0xFF;</span>
<span class="nc bnc" id="L126" title="All 6 branches missed.">            if (ch &gt;= ' ' &amp;&amp; ch &lt;= '~' &amp;&amp; ch != '\\') {</span>
<span class="nc" id="L127">                result.append((char) ch);</span>
            } else {
<span class="nc" id="L129">                result.append(&quot;\\x&quot;);</span>
<span class="nc" id="L130">                result.append(HEX_CHARS_UPPER[ch / 0x10]);</span>
<span class="nc" id="L131">                result.append(HEX_CHARS_UPPER[ch % 0x10]);</span>
            }
        }
<span class="nc" id="L134">        return result.toString();</span>
    }

    /**
     * A byte array comparator based on lexicograpic ordering.
     */
<span class="nc" id="L140">    public final static Comparator&lt;byte[]&gt; BYTES_LEXICO_COMPARATOR = new LexicographicByteArrayComparator();</span>

    private interface ByteArrayComparator extends Comparator&lt;byte[]&gt; {

        int compare(final byte[] buffer1, int offset1, int length1,
                    final byte[] buffer2, int offset2, int length2);
    }

<span class="nc" id="L148">    private static class LexicographicByteArrayComparator implements ByteArrayComparator {</span>

        @Override
        public int compare(byte[] buffer1, byte[] buffer2) {
<span class="nc" id="L152">            return compare(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length);</span>
        }

        public int compare(final byte[] buffer1, int offset1, int length1,
                           final byte[] buffer2, int offset2, int length2) {

            // short circuit equal case
<span class="nc bnc" id="L159" title="All 6 branches missed.">            if (buffer1 == buffer2 &amp;&amp;</span>
                    offset1 == offset2 &amp;&amp;
                    length1 == length2) {
<span class="nc" id="L162">                return 0;</span>
            }

            // similar to Arrays.compare() but considers offset and length
<span class="nc" id="L166">            int end1 = offset1 + length1;</span>
<span class="nc" id="L167">            int end2 = offset2 + length2;</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">            for (int i = offset1, j = offset2; i &lt; end1 &amp;&amp; j &lt; end2; i++, j++) {</span>
<span class="nc" id="L169">                int a = buffer1[i] &amp; 0xff;</span>
<span class="nc" id="L170">                int b = buffer2[j] &amp; 0xff;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                if (a != b) {</span>
<span class="nc" id="L172">                    return a - b;</span>
                }
            }
<span class="nc" id="L175">            return length1 - length2;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>